<?php
// $Id$

/**
 * @file
 * Provides facets based on taxonomy (categories).
 */

require_once('./'. drupal_get_path('module', 'faceted_search') .'/faceted_search.inc');

/**
 * Implementation of hook_menu().
 */
function taxonomy_facets_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/faceted_search/taxonomy_facets',
      'title' => t('Taxonomy index'),
      'callback' => 'taxonomy_facets_index_page',
      'access' => user_access('administer site configuration'),
      'type' => MENU_LOCAL_TASK,
    );
    $items[] = array(
      'path' => 'admin/settings/faceted_search/taxonomy_facets/rebuild',
      'callback' => 'taxonomy_facets_index_rebuild',
      'access' => user_access('administer site configuration'),
      'type' => MENU_CALLBACK,
    );
  }
  
  return $items;
}

/**
 * Implementation of hook_nodeapi().
 *
 * Update the taxonomy facets index with a node's terms.
 */
function taxonomy_facets_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'delete':
      _taxonomy_facets_index_clear_node($node->nid);
      break;

    case 'insert':
      if ($node->status) {
        _taxonomy_facets_index_update_node($node->nid, $node->taxonomy);
      }
      break;
      
    case 'update':
      if ($node->status) {
        _taxonomy_facets_index_update_node($node->nid, $node->taxonomy);
      }
      else {
        _taxonomy_facets_index_clear_node($node->nid);
      }
      break;
  }
}

/**
 * Implementation of hook_taxonomy().
 *
 * Update the taxonomy facets index when the taxonomy changes.
 *
 * This needs to be handled to ensure that hierarchy changes are taken into
 * account. A difficulty here is that the former hierarchy is not available at
 * this point, so we can't identify the former ancestors and children of the
 * term so that the node associations with all terms involved can be updated.
 */
// TODO: A brute force solution (commented out below) would update the whole
// vocabulary, but performance-wise that's an unacceptable solution. We might
// need to prepend our own submit function to the term editing form, and then
// check the term hierarchy before it's replaced.
/*
function taxonomy_facets_taxonomy($op, $type, $array = NULL) {
  if ($type == 'term') {
    switch ($op) {
      case 'delete':
      case 'update':
        _taxonomy_facets_index_update_vocabulary($array['vid']);
        break;
    }
  }
}
*/

/**
 * Implementation of hook_faceted_search_collect().
 */
function taxonomy_facets_faceted_search_collect(&$facets, $domain, $env_id, $filter, $arg = NULL) {
  switch ($domain) {
    case 'all':
      $vocabularies = taxonomy_get_vocabularies();
      foreach ($vocabularies as $vocabulary) {
        // If the vocabulary's corresponding facet is allowed.
        if (!isset($filter) || isset($filter['taxonomy'][$vocabulary->vid])) {
          $facets[] = new taxonomy_facet($vocabulary);
        }
      }
      break;

    case 'text':
      // Scan the given search text for a 'taxonomy:{path,path,path,...}' token,
      // and create facets from it.
      $vocabularies = taxonomy_get_vocabularies();
      if ($found_text = search_query_extract($arg, 'taxonomy')) {
        // Extract separate facets
        $paths = explode(',', $found_text);
        foreach ($paths as $path_index => $tids) {
          $tids = explode('.', $tids); // Extract path of tids
          $path = array(); // Array to collect path of categories
          $previous_tid = 0;
          foreach ($tids as $tid) {
            if (!is_numeric($tid) || $tid <= 0) {
              break; // Invalid tid
            }
            $term = taxonomy_get_term($tid);
            if (!$term) {
              break; // No term for tid
            }
            if (!isset($vocabularies[$term->vid]) || (isset($filter) && !isset($filter['taxonomy'][$term->vid]))) {
              break; // Term's vocabulary not allowed.
            }
            if ($previous_tid != 0) {
              $parents = taxonomy_get_parents($tid);
              if (!isset($parents[$previous_tid])) {
                break; // Term is not a child of the previous term in path
              }
            }
            // Add category to current path.
            if ($vocabularies[$term->vid]->hierarchy) {
              // TODO: Fix potential problem if parents of the first tid have been omitted from $tids
              $path[] = new taxonomy_facet_hierarchical_category($term->tid, $term->name); 
            }
            else {
              $path[] = new taxonomy_facet_category($term->tid, $term->name);
            }
            $previous_tid = $tid;
          }
          // If found some categories in the current path of tids, build a facet
          if (count($path) > 0) {
            $facets[] = new taxonomy_facet($vocabularies[$term->vid], $path);
          }
        }

        // Remove the parsed token from the search text.
        $arg = search_query_insert($arg, 'taxonomy');
      }
      return $arg;

    case 'node':
      $vocabularies = taxonomy_get_vocabularies();
      foreach ($arg->taxonomy as $term) {
        $vid = $term->vid;
        // If the vocabulary's corresponding facet is allowed.
        if (isset($vocabularies[$vid]) && (!isset($filter) || isset($filter['taxonomy'][$vid]))) {
          $path = array();
          // Retrieve ancestor terms.
          while ($term) {
            if ($vocabularies[$vid]->hierarchy) {
              $category = new taxonomy_facet_hierarchical_category($term->tid, $term->name);
            }
            else {
              $category = new taxonomy_facet_category($term->tid, $term->name);
            }
            array_unshift($path, $category);
            $parents = taxonomy_get_parents($term->tid);
            $term = reset($parents); // Keep only the first parent
          }
          if ($path) {
            // Create a facet with the found term as the active category.
            $facets[] = new taxonomy_facet($vocabularies[$vid], $path);
          }
        }
      }
      break;
  }
}

/**
 * Menu callback for the index page.
 */
function taxonomy_facets_index_page() {
  if (count(taxonomy_get_vocabularies())) {
    $form['indexing'] = array(
      '#type' => 'fieldset',
      '#title' => t('Indexing'),
    );
    $form['indexing']['taxonomy_facets_rebuild'] = array(
      '#type' => 'markup',
      '#value' => t('If you are getting inconsistent results when navigating taxonomy facets, try to <a href="@rebuild">rebuild the Taxonomy Facets index</a>. However, inconsistencies might denote a bug; please report any bug to Faceted Search\'s <a href="http://drupal.org/project/issues/faceted_search">issue queue</a>.', array('@rebuild' => url('admin/settings/faceted_search/taxonomy_facets/rebuild'))),
    );
    return drupal_render($form);
  }
  else {
    return '<p>'. t('There are currently no vocabularies. Go to the !page first to create vocabularies.', array('!page' => l(t('Categories page'), 'admin/content/taxonomy'))) .'</p>';
  }
}

/**
 * Implementation of hook_form_alter().
 */
function taxonomy_facets_form_alter($form_id, &$form) {
  if ($form_id == 'faceted_search_edit_form') {
    // Prepend submit function (must be called before the settings are saved).
    $form['#submit'] = array('taxonomy_facets_edit_form_submit' => array()) + $form['#submit'];
  }
}

/**
 * Submit callback for the environment edit form.
 *
 * Check what vocabularies have been enabled/disabled, and update the index
 * accordingly.
 */
function taxonomy_facets_edit_form_submit($form_id, $form_values) {
  $env_id = $form_values['env_id'];
  
  // Find the previous status of vocabularies for the current environment.
  $old_status = array();
  $results = db_query("SELECT facet_id AS vid, status FROM {faceted_search_facets} WHERE facet_key = 'taxonomy' AND env_id = %d", $env_id);
  while ($db_settings = db_fetch_object($results)) {
    $old_status[$db_settings->vid] = $db_settings->status;
  }

  // Find which vocabularies have changed status in the current environment.
  $new_status = array();
  $vocabularies = taxonomy_get_vocabularies();
  foreach (array_keys($vocabularies) as $vid) {
    if (isset($form_values['facets']['taxonomy_'. $vid]['status'])) {
      $form_status = $form_values['facets']['taxonomy_'. $vid]['status'];
      if (!isset($old_status[$vid]) || $old_status[$vid] != $form_status) {
        if ($form_status) {
          $new_status[$vid] = TRUE;
        }
        else {
          $new_status[$vid] = FALSE;
        }
      }
    }
    else {
      $new_status[$vid] = FALSE;
    }
  }

  // Update the index.
  foreach ($new_status as $vid => $status) {
    // If no other environment is using the vocabulary.
    if (db_result(db_query("SELECT COUNT(*) FROM {faceted_search_facets} WHERE env_id != %d AND facet_key = 'taxonomy' AND facet_id = %d AND status = 1", $env_id, $vid)) == 0) {
      if ($status) {
        // This is the first environment to use the vocabulary; update the index.
        _taxonomy_facets_index_update_vocabulary($vid);
      }
      elseif ($env_id) { // If this is not a new environment.
        // This was the last environment to use the vocabulary; clear the
        // vocabulary from the index.
        _taxonomy_facets_index_clear_vocabulary($vid);
      }
    }
  }
}

/**
 * Menu callback for rebuilding the taxonomy_facets_term_node table.
 */
function taxonomy_facets_index_rebuild($goto_admin = TRUE) {
  $vocabularies = taxonomy_facets_get_vocabularies();
  if (count($vocabularies)) {
    foreach ($vocabularies as $vid => $vocabulary) {
      if ($vocabulary->hierarchy) {
        _taxonomy_facets_index_update_vocabulary($vid);
        drupal_set_message(t('The Taxonomy Facets index has been updated for the %vocabulary vocabulary.', array('%vocabulary' => $vocabulary->name)));
      }
    }
  }
  else {
    drupal_set_message(t('No taxonomy facets have been enabled in any faceted search environment. No update needed.'));
  }
  if ($goto_admin) {
    drupal_goto('admin/settings/faceted_search/taxonomy_facets');
  }
}

/**
 * Return an array of all vocabulary objects that have been enabled for use in
 * faceted searches.
 */
function taxonomy_facets_get_vocabularies() {
  $vocabularies = array();
  $all_vocabularies = taxonomy_get_vocabularies();
  $results = db_query("SELECT facet_id AS vid FROM {faceted_search_facets} WHERE facet_key = 'taxonomy' AND status = 1");
  while ($result = db_fetch_object($results)) {
    $vocabularies[$result->vid] = $all_vocabularies[$result->vid];
  }
  return $vocabularies;
}

/**
 * A taxonomy-based facet.
 *
 * @see taxonomy_facet_category
 */
class taxonomy_facet extends faceted_search_facet {
  /**
   * The vocabulary used by this facet. 
   */
  var $_vocabulary = NULL;

  /**
   * Constructor. 
   */
  function taxonomy_facet($vocabulary, $active_path = array()) {
    parent::faceted_search_facet('taxonomy', $active_path);
    $this->_vocabulary = $vocabulary;
    parent::set_weight($vocabulary->weight); // Assign default weight.
  }

  /**
   * Returns the id of this facet.
   */
  function get_id() {
    return $this->_vocabulary->vid;
  }

  /**
   * Returns the label of this facet.
   */
  function get_label() {
    return $this->_vocabulary->name;
  }

  /**
   * Returns the available sort options for this facet.
   */
  function get_sort_options() {
    $options = parent::get_sort_options();
    $options['term'] = t('Category'); // Term weight & name.
    return $options;
  }

  /**
   * Handler for the 'count' sort criteria.
   */
  function build_sort_query_count(&$query) {
    $query->add_orderby('count', 'DESC');
    $query->add_orderby('term_data.weight', 'ASC');
    $query->add_orderby('term_data.name', 'ASC');
  }

  /**
   * Handler for the 'term' sort criteria.
   */
  function build_sort_query_term(&$query) {
    $query->add_orderby('term_data.weight', 'ASC');
    $query->add_orderby('term_data.name', 'ASC');
  }

  /**
   * Returns the search text for this facet, taking into account this facet's
   * active path.
   */
  function get_text() {
    return implode('.', array_map('_taxonomy_facets_get_category_tid', $this->get_active_path()));
  }

  /**
   * Updates a query for retrieving the root categories of this facet and their
   * associated nodes within the current search results. 
   *
   * @param $query
   *   The query object to update.
   *
   * @return
   *   FALSE if this facet can't have root categories.
   */
  function build_root_categories_query(&$query) {
    if ($this->_vocabulary->hierarchy) {
      $query->add_table('taxonomy_facets_term_node', 'nid', 'n', 'nid', 'term_node');
      $query->add_table('term_hierarchy', 'tid', 'term_node', 'tid');
      $query->add_where('term_hierarchy.parent = 0');
    }
    else {
      $query->add_table('term_node', 'nid');
    }
    $query->add_table('term_data', 'tid', 'term_node', 'tid');
    $query->add_field('term_data', 'tid');
    $query->add_field('term_data', 'name');
    $query->add_where('term_data.vid = %d', $this->_vocabulary->vid);
    $query->add_groupby('term_data_tid'); // Needed for counting matching nodes.
    return TRUE;
  }
  
  /**
   * This factory method creates categories given query results that include the
   * fields selected in get_root_categories_query() or get_subcategories_query().
   *
   * @param $results
   *   $results A database query result resource.
   *
   * @return
   *   Array of categories.
   */
  function build_categories($results) {
    $categories = array();
    while ($result = db_fetch_object($results)) {
      if ($this->_vocabulary->hierarchy) {
        $categories[] = new taxonomy_facet_hierarchical_category($result->term_data_tid, $result->term_data_name, $result->count);
      }
      else {
        $categories[] = new taxonomy_facet_category($result->term_data_tid, $result->term_data_name, $result->count);
      }
    }
    return $categories;
  }
}

/**
 * A category for non-hierarchical taxonomy-based facets.
 *
 * @see taxonomy_facet
 */
class taxonomy_facet_category extends faceted_search_category {
  var $_tid = NULL;
  var $_name = '';

  /**
   * Constructor.
   */
  function taxonomy_facet_category($tid, $name, $count = NULL) {
    parent::faceted_search_category($count);
    $this->_tid = $tid;
    $this->_name = $name;
  }

  /**
   * Return the label of this category.
   */
  function get_label() {
    return $this->_name;
  }

  /**
   * Updates a query for selecting nodes matching this category.
   *
   * @param $query
   *   The query object to update.
   */
  function build_results_query(&$query) {
    // Since multiple terms might be used and cause multiple joins of
    // taxonomy_facets_term_node, we add the tid into the table alias to ensure
    // a unique alias.
    $query->add_table('term_node', 'nid', 'n', 'nid', "term_node_{$this->_tid}");
    $query->add_where("term_node_{$this->_tid}.tid = %d", $this->_tid);
  }
}

/**
 * A category for hierarchical taxonomy-based facets. 
 *
 * @see taxonomy_facet
 */
class taxonomy_facet_hierarchical_category extends taxonomy_facet_category {

  /**
   * Constructor.
   */
  function taxonomy_facet_hierarchical_category($tid, $name, $count = NULL) {
    parent::taxonomy_facet_category($tid, $name, $count);
  }

  /**
   * Updates a query for retrieving the subcategories of this category and their
   * associated nodes within the current search results. 
   *
   * This only needs to be overridden for hierarchical facets.
   *
   * @param $query
   *   The query object to update.
   *
   * @return
   *   FALSE if this facet can't have subcategories.
   */
  function build_subcategories_query(&$query) {
    $query->add_table('taxonomy_facets_term_node', 'nid', 'n', 'nid', 'term_node');
    $query->add_table('term_data', 'tid', 'term_node', 'tid');
    $query->add_table('term_hierarchy', 'tid', 'term_node', 'tid');
    $query->add_field('term_data', 'tid');
    $query->add_field('term_data', 'name');
    $query->add_where('term_hierarchy.parent = %d', $this->_tid);
    $query->add_groupby('term_data_tid'); // Needed for counting matching nodes.
    return TRUE;
  }

  /**
   * Updates a query for selecting nodes matching this category.
   *
   * @param $query
   *   The query object to update.
   */
  function build_results_query(&$query) {
    // Since multiple terms might be used and cause multiple joins of
    // taxonomy_facets_term_node, we add the tid into the table alias to ensure
    // a unique alias.
    $query->add_table('taxonomy_facets_term_node', 'nid', 'n', 'nid', "term_node_{$this->_tid}");
    $query->add_where("term_node_{$this->_tid}.tid = %d", $this->_tid);
  }
}

// --------------------------------------------------------------------------
// Internal stuff

/**
 * Return the id of the specified category. Useful for array_map().
 */
function _taxonomy_facets_get_category_tid($category) {
  return $category->_tid;
}

/**
 * Update terms from the specified vocabulary to the taxonomy_facets_term_node
 * table, based on the existing term_node table.
 *
 * This table is usually updated through hook_nodeapi(), but we need to populate
 * the table when a vocabulary is enabled for faceted searches.
 */
// TODO: This should be done through cron
function _taxonomy_facets_index_update_vocabulary($vid) {
  _taxonomy_facets_index_clear_vocabulary($vid);

  // For all nodes using terms from the vocabulary.
  $result = db_query('SELECT tn.tid, tn.nid FROM {term_node} tn INNER JOIN {term_data} t ON t.tid = tn.tid WHERE t.vid = %d', $vid);
  while ($tn = db_fetch_object($result)) {
    $ancestors = taxonomy_get_parents_all($tn->tid);
    foreach ($ancestors as $term) {
      $count = db_result(db_query('SELECT COUNT(*) FROM {taxonomy_facets_term_node} WHERE tid = %d AND nid = %d', $term->tid, $tn->nid));
      // If not already there (could be there already since many terms can share common ancestors).
      if ($count == 0) {
        db_query('INSERT INTO {taxonomy_facets_term_node} SET tid = %d, nid = %d', $term->tid, $tn->nid);
      }
    }
  }    
}

/**
 * Clear the taxonomy_facets_term_node table from terms of the specified vocabulary.
 */
function _taxonomy_facets_index_clear_vocabulary($vid) {
  db_query('DELETE tn FROM {taxonomy_facets_term_node} tn, {term_data} t WHERE tn.tid = t.tid AND t.vid = %d', $vid);
}

/**
 * Update the saved term associations for the specified node.
 */
function _taxonomy_facets_index_update_node($nid, $terms) {
  _taxonomy_facets_index_clear_node($nid);
  
  if (count($terms) == 0) {
    return;
  }
  // Get allowed vocabularies.
  $vocabularies = taxonomy_facets_get_vocabularies();
  if (count($vocabularies) == 0) {
    return;
  }

  $tids = array();
  
  // Collect the free tags to save.
  if (isset($terms['tags'])) {
    // Note: This is based on taxonomy_node_save().
    $input = $terms['tags'];
    unset($terms['tags']);
    foreach ($input as $vid => $vid_value) {
      if (!isset($vocabularies[$vid])) {
        continue;
      }
      
      // This regexp allows the following types of user input:
      // this, "somecmpany, llc", "and ""this"" w,o.rks", foo bar
      $regexp = '%(?:^|,\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^",]*))%x';
      preg_match_all($regexp, $vid_value, $matches);
      $input_terms = array_unique($matches[1]);

      $inserted = array();
      foreach ($input_terms as $input_term) {
        // If a user has escaped a term (to demonstrate that it is a group, or
        // includes a comma or quote character), we remove the escape formatting
        // so to save the term into the database as the user intends.
        $input_term = str_replace('""', '"', preg_replace('/^"(.*)"$/', '\1', $input_term));
        $input_term = trim($input_term);
        if ($input_term == '') {
          continue;
        }

        // Return the term's tid. Note: This assumes that taxonomy_node_save()
        // has been called previously!
        $possibilities = taxonomy_get_term_by_name($input_term);
        $input_term_tid = NULL; // tid match, if any.
        foreach ($possibilities as $possibility) {
          if ($possibility->vid == $vid) {
            // Note: Should break here, but taxonomy_node_save() doesn't. Can't
            // save $input_term_tid in $tids here, since that would append all
            // the possibilities instead of the last one.
            $input_term_tid = $possibility->tid;
          }
        }
        if ($input_term_tid) {
          $tids[] = $input_term_tid;
        }
      }
    }
  }
  
  // Collect the taxonomy terms to save.
  foreach ($terms as $key => $value) {
    if (is_array($value)) {
      // We are looking at an array of tids indexed by vid.
      if (isset($vocabularies[$key])) {
        $tids = array_merge($tids, $value);
      }
    }
    elseif (is_object($value)) {
      // We are looking at a term. Note: Not sure how this can happen, but it
      // has been reported, and taxonomy_node_save() handles this case.
      if (isset($vocabularies[$value->vid])) {
        $tids[] = $value->tid;
      }
    }
    elseif ($value) {
      // We are looking at a tid. Note: Not sure how this can happen, but
      // taxonomy_node_save() handles this case.
      if (isset($vocabularies[$key])) {
        $tids[] = $value;
      }
    }
  }
  if ($tids) {
    _taxonomy_facets_index_save_node($nid, $tids);
  }
}

/**
 * Save the specified terms (and their ancestors) in the
 * taxonomy_facets_term_node table.
 */
function _taxonomy_facets_index_save_node($nid, $tids) {
  foreach ($tids as $tid) {
    $ancestors = taxonomy_get_parents_all($tid);
    foreach ($ancestors as $term) {
      // If term has not been inserted yet, insert it (multiple terms may share
      // common ancestors)
      if (!isset($inserted[$term->tid])) {
        $inserted[$term->tid] = TRUE;
        db_query("INSERT INTO {taxonomy_facets_term_node} (nid, tid) VALUES (%d, %d)", $nid, $term->tid);
      }
    }
  }
}

/**
 * Clear the term associations for the specified node.
 */
function _taxonomy_facets_index_clear_node($nid) {
  db_query("DELETE FROM {taxonomy_facets_term_node} WHERE nid = %d", $nid);
}

