<?php
// $Id$

/**
 * @file
 * Provides facets based on taxonomy (categories).
 */

require_once('./'. drupal_get_path('module', 'faceted_search') .'/faceted_search.inc');

/**
 * Implementation of hook_menu().
 */
function taxonomy_facets_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/faceted_search/taxonomy_facets',
      'title' => t('Taxonomy Facets'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('taxonomy_facets_admin_settings_form'),
      'access' => user_access('administer site configuration'),
      'type' => MENU_LOCAL_TASK,
    );
    $items[] = array(
      'path' => 'admin/settings/faceted_search/taxonomy_facets/rebuild',
      'callback' => 'taxonomy_facets_rebuild_term_node',
      'access' => user_access('administer site configuration'),
      'type' => MENU_CALLBACK,
    );
  }
  
  return $items;
}

/**
 * Implementation of hook_nodeapi().
 */
function taxonomy_facets_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'delete':
      _taxonomy_facets_clear_term_node($node->nid);
      break;

    case 'insert':
      if ($node->status) {
        _taxonomy_facets_update_term_node($node->nid, $node->taxonomy);
      }
      break;
      
    case 'update':
      if ($node->status) {
        _taxonomy_facets_update_term_node($node->nid, $node->taxonomy);
      }
      else {
        _taxonomy_facets_clear_term_node($node->nid);
      }
      break;
  }
}

/**
 * Implementation of hook_faceted_search_list().
 *
 * @return
 *   Array of available facets.
 */
function taxonomy_facets_faceted_search_list() {
  $facets = array();

  $vocabularies = taxonomy_facets_get_vocabularies();
  foreach ($vocabularies as $vocabulary) {
    $facets[] = new taxonomy_facet($vocabulary);
  }
  
  return $facets;
}

/**
 * Implementation of hook_faceted_search_parse().
 *
 * Scan the given search text for a 'taxonomy:{path,path,path,...}' token, and
 * extract facets from it.
 *
 * @param &$text
 *   Text to parse. Once the desired token has been extracted, it is removed
 *   from the text.
 *
 * @return
 *   Array of facets.
 */
function taxonomy_facets_faceted_search_parse(&$text) {
  $facets = array();
  $vocabularies = taxonomy_facets_get_vocabularies();

  if ($found_text = search_query_extract($text, 'taxonomy')) {
    // Extract separate facets
    $paths = explode(',', $found_text);
    foreach ($paths as $path_index => $tids) {
      $tids = explode('.', $tids); // Extract path of tids
      $path = array(); // Array to collect path of categories
      $previous_tid = 0;
      foreach ($tids as $tid) {
        if (!is_numeric($tid) || $tid <= 0) {
          break; // Invalid tid
        }
        $term = taxonomy_get_term($tid);
        if (!$term) {
          break; // No term for tid
        }
        if (!isset($vocabularies[$term->vid])) {
          break; // Term's vocabulary not enabled for faceted search
        }
        if ($previous_tid != 0) {
          $parents = taxonomy_get_parents($tid);
          if (!isset($parents[$previous_tid])) {
            break; // Term is not a child of the previous term in path
          }
        }
        // TODO: Fix potential problem if parents of the first tid have been omitted from $tids
        $path[] = new taxonomy_facet_category($term->tid, $term->name); // Add category to current path
        $previous_tid = $tid;
      }
      // If found some categories in the current path of tids, build a facet
      if (count($path) > 0) {
        $facets[] = new taxonomy_facet($vocabularies[$term->vid], $path);
      }
    }

    // Remove the parsed text
    $text = search_query_insert($text, 'taxonomy');
  }

  return $facets;
}

/**
 * Implementation of hook_faceted_search_collect().
 *
 * Collect facets from the specified node's taxonomy. All returned facets will
 * have an active path reflecting the node's taxonomy.
 *
 * @return
 *   Array of facets. 
 */
function taxonomy_facets_faceted_search_collect($node) {
  $facets = array();
  $vocabularies = taxonomy_facets_get_vocabularies();

  foreach ($node->taxonomy as $term) {
    $vid = $term->vid;
    if (isset($vocabularies[$vid])) {
      $path = array();
      // Retrieve ancestor terms
      while ($term) {
        array_unshift($path, new taxonomy_facet_category($term->tid, $term->name));
        $parents = taxonomy_get_parents($term->tid);
        $term = reset($parents); // Keep only the first parent
      }
      if ($path) {
        $facets[] = new taxonomy_facet($vocabularies[$vid], $path);
      }
    }
  }

  return $facets;
}

/**
 * Menu callback for the administration settings.
 */
function taxonomy_facets_admin_settings_form() {
  $vocabularies = array();
  foreach (taxonomy_get_vocabularies() as $vocabulary) {
    $vocabularies[$vocabulary->vid] = $vocabulary->name;
  }
  if (count($vocabularies)) {
    $form['taxonomy_facets_vocabularies'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Vocabularies to use as facets'),
      '#description' => t('Check the vocabularies that shall be used in faceted searches. Note that the default weight of each facet will equal the weight of its corresponding vocabulary.'),
      '#options' => $vocabularies,
      '#default_value' => variable_get('taxonomy_facets_vocabularies', array()),
    );
    $form['indexing'] = array(
      '#type' => 'fieldset',
      '#title' => t('Indexing'),
    );
    // TODO: provide some status on the taxonomy facets index (whether or not it
    // needs to be rebuilt). Or better, detect the condition and just do it when
    // the module becomes enabled.
    $form['indexing']['taxonomy_facets_rebuild'] = array(
      '#type' => 'markup',
      '#value' => t('If you are getting inconsistent results when navigating the taxonomy facets, try to <a href="@rebuild">rebuild the Taxonomy Facets index</a>. However, inconsistencies might denote a bug; please report it to Faceted Search\'s <a href="http://drupal.org/project/issues/faceted_search">issue queue</a>.', array('@rebuild' => url('admin/settings/faceted_search/taxonomy_facets/rebuild'))),
    );
    $form['#submit']['taxonomy_facets_admin_settings_form_submit'] = array(); // Must be called first
    $form['#submit']['system_settings_form_submit'] = array();
  }
  else {
    $form['message'] = array(
      '#value' => '<p>'. t('There are currently no vocabularies. Go to the !page first to create vocabularies.', array('!page' => l(t('Categories page'), 'admin/content/taxonomy'))) .'</p>',
    );
  }
  return system_settings_form($form);
}

/**
 * Submit callback for the administration settings.
 */
function taxonomy_facets_admin_settings_form_submit($form_id, $form_values) {
  $vocabularies = variable_get('taxonomy_facets_vocabularies', array());
  if (count($form_values['taxonomy_facets_vocabularies'])) {
    foreach ($form_values['taxonomy_facets_vocabularies'] as $vid => $status) {
      if ($vocabularies[$vid] != $status) {
        $vocabulary = taxonomy_get_vocabulary($vid);
        if ($status) {
          _taxonomy_facets_update_term_node_vid($vid);
          drupal_set_message(t('The Taxonomy Facets index has been updated for the %vocabulary vocabulary.', array('%vocabulary' => $vocabulary->name)));
        }
        else {
          _taxonomy_facets_clear_term_node_vid($vid);
          drupal_set_message(t('The Taxonomy Facets index has been cleared for the %vocabulary vocabulary.', array('%vocabulary' => $vocabulary->name)));
        }
      }
    }
  }
}

/**
 * Menu callback for rebuilding the taxonomy_facets_term_node table.
 */
function taxonomy_facets_rebuild_term_node($goto_admin = TRUE) {
  $vocabularies = taxonomy_facets_get_vocabularies();
  if ($vocabularies) {
    foreach ($vocabularies as $vid => $vocabulary) {
      _taxonomy_facets_update_term_node_vid($vid);
    }
    drupal_set_message(t('The Taxonomy Facets index has been updated.'));
  }
  if ($goto_admin) {
    drupal_goto('admin/settings/faceted_search/taxonomy_facets');
  }
}

/**
 * Return an array of all vocabulary objects that have been enabled for use in
 * faceted searches.
 */
function taxonomy_facets_get_vocabularies() {
  $vocabularies = array();
  $settings = variable_get('taxonomy_facets_vocabularies', array());
  // Fill the return array with vocabulary objects.
  $all_vocabularies = taxonomy_get_vocabularies();
  foreach ($all_vocabularies as $vocabulary) {
    if ($settings[$vocabulary->vid]) {
      $vocabularies[$vocabulary->vid] = $vocabulary;
    }
  }
  return $vocabularies;
}

/**
 * A taxonomy-based facet.
 *
 * @see taxonomy_facet_category
 */
class taxonomy_facet extends faceted_search_facet {
  /**
   * The vocabulary used by this facet. 
   */
  var $_vocabulary = NULL;

  /**
   * Constructor. 
   */
  function taxonomy_facet($vocabulary, $active_path = array()) {
    parent::faceted_search_facet('taxonomy', $active_path);
    $this->_vocabulary = $vocabulary;
  }

  /**
   * Returns the id of this facet.
   */
  function get_id() {
    return $this->_vocabulary->vid;
  }

  /**
   * Returns the label of this facet.
   */
  function get_label() {
    return $this->_vocabulary->name;
  }

  /**
   * Returns the default weight of this facet.
   */
  function get_default_weight() {
    return $this->_vocabulary->weight;
  }

  /**
   * Returns the available sort options for this facet.
   */
  function get_sort_options() {
    $options = parent::get_sort_options();
    $options['term'] = t('Category'); // Term weight & name.
    return $options;
  }

  /**
   * Handler for the 'count' sort criteria.
   */
  function build_sort_query_count(&$query) {
    $query->add_orderby('count', 'DESC');
    $query->add_orderby('term_data.weight', 'ASC');
    $query->add_orderby('term_data.name', 'ASC');
  }

  /**
   * Handler for the 'term' sort criteria.
   */
  function build_sort_query_term(&$query) {
    $query->add_orderby('term_data.weight', 'ASC');
    $query->add_orderby('term_data.name', 'ASC');
  }

  /**
   * Returns the search text for this facet, taking into account this facet's
   * active path.
   */
  function get_text() {
    return implode('.', array_map('_taxonomy_facets_get_category_tid', $this->get_active_path()));
  }

  /**
   * Updates a query for retrieving the root categories of this facet and their
   * associated nodes within the current search results. 
   *
   * @param $query
   *   The query object to update.
   *
   * @return
   *   FALSE if this facet can't have root categories.
   */
  function build_root_categories_query(&$query) {
    $query->add_table('taxonomy_facets_term_node', 'nid');
    $query->add_table('term_data', 'tid', 'taxonomy_facets_term_node', 'tid');
    $query->add_table('term_hierarchy', 'tid', 'taxonomy_facets_term_node', 'tid');
    $query->add_field('term_data', 'tid');
    $query->add_field('term_data', 'name');
    $query->add_where('term_data.vid = %d', $this->_vocabulary->vid);
    $query->add_where('term_hierarchy.parent = 0');
    $query->add_groupby('term_data_tid'); // Needed for counting matching nodes.
    return TRUE;
  }
  
  /**
   * This factory method creates categories given query results that include the
   * fields selected in get_root_categories_query() or get_subcategories_query().
   *
   * @param $results
   *   $results A database query result resource.
   *
   * @return
   *   Array of categories.
   */
  function build_categories($results) {
    $categories = array();
    while ($result = db_fetch_object($results)) {
      $categories[] = new taxonomy_facet_category($result->term_data_tid, $result->term_data_name, $result->count);
    }
    return $categories;
  }
}

/**
 * A category for taxonomy-based facets. 
 *
 * @see taxonomy_facet
 */
class taxonomy_facet_category extends faceted_search_category {
  var $_tid = NULL;
  var $_name = '';

  /**
   * Constructor.
   */
  function taxonomy_facet_category($tid, $name, $count = NULL) {
    parent::faceted_search_category($count);
    $this->_tid = $tid;
    $this->_name = $name;
  }

  /**
   * Return the label of this category.
   */
  function get_label() {
    return $this->_name;
  }

  /**
   * Updates a query for retrieving the subcategories of this category and their
   * associated nodes within the current search results. 
   *
   * This only needs to be overridden for hierarchical facets.
   *
   * @param $query
   *   The query object to update.
   *
   * @return
   *   FALSE if this facet can't have subcategories.
   */
  function build_subcategories_query(&$query) {
    $query->add_table('taxonomy_facets_term_node', 'nid');
    $query->add_table('term_data', 'tid', 'taxonomy_facets_term_node', 'tid');
    $query->add_table('term_hierarchy', 'tid', 'taxonomy_facets_term_node', 'tid');
    $query->add_field('term_data', 'tid');
    $query->add_field('term_data', 'name');
    $query->add_where('term_hierarchy.parent = %d', $this->_tid);
    $query->add_groupby('term_data_tid'); // Needed for counting matching nodes.
    return TRUE;
  }

  /**
   * Updates a query for selecting nodes matching this category.
   *
   * @param $query
   *   The query object to update.
   */
  function build_results_query(&$query) {
    // Since multiple terms might be used and cause multiple joins of
    // taxonomy_facets_term_node, we add the tid into the table alias to ensure
    // a unique alias.
    $query->add_table('taxonomy_facets_term_node', 'nid', 'node', 'nid', "taxonomy_facets_term_node_{$this->_tid}");
    $query->add_where("taxonomy_facets_term_node_{$this->_tid}.tid = %d", $this->_tid);
  }
}

// --------------------------------------------------------------------------
// Internal stuff

/**
 * Return the id of the specified category. Useful for array_map().
 */
function _taxonomy_facets_get_category_tid($category) {
  return $category->_tid;
}

/**
 * Add initial terms from the specified vocabulary to the
 * taxonomy_facets_term_node table, based on the existing term_node table.
 *
 * This table is usually updated through hook_nodeapi(), but we need to populate
 * the table when a vocabulary is enabled for faceted searches.
 */
// TODO: This should be done through cron
function _taxonomy_facets_update_term_node_vid($vid) {
  _taxonomy_facets_clear_term_node_vid($vid);

  $result = db_query("SELECT tn.tid, tn.nid FROM {term_node} tn INNER JOIN {term_data} t ON t.tid = tn.tid WHERE t.vid = %d", $vid);
  while ($tn = db_fetch_object($result)) {
    $ancestors = taxonomy_get_parents_all($tn->tid);
    foreach ($ancestors as $term) {
      $count = db_result(db_query("SELECT COUNT(*) FROM {taxonomy_facets_term_node} WHERE tid = %d AND nid = %d", $term->tid, $tn->nid));
      // If not already there (which is possible, since many terms can share common ancestors)
      if ($count == 0) {
        db_query("INSERT INTO {taxonomy_facets_term_node} SET tid = %d, nid = %d", $term->tid, $tn->nid);
      }
    }
  }    
}

/**
 * Clear the taxonomy_facets_term_node table from terms of the specified vocabulary.
 */
function _taxonomy_facets_clear_term_node_vid($vid) {
  db_query("DELETE tn FROM {taxonomy_facets_term_node} tn, {term_data} t WHERE tn.tid = t.tid AND t.vid = %d", $vid);
}

/**
 * Update the saved term associations for the specified node.
 */
function _taxonomy_facets_update_term_node($nid, $terms) {
  _taxonomy_facets_clear_term_node($nid);
  
  if (count($terms) == 0) {
    return;
  }
  // Get allowed vocabularies.
  $vocabularies = taxonomy_facets_get_vocabularies();
  if (count($vocabularies) == 0) {
    return;
  }

  $tids = array();
  
  // Collect the free tags to save.
  if (isset($terms['tags'])) {
    // Note: This is based on taxonomy_node_save().
    $input = $terms['tags'];
    unset($terms['tags']);
    foreach ($input as $vid => $vid_value) {
      if (!isset($vocabularies[$vid])) {
        continue;
      }
      
      // This regexp allows the following types of user input:
      // this, "somecmpany, llc", "and ""this"" w,o.rks", foo bar
      $regexp = '%(?:^|,\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^",]*))%x';
      preg_match_all($regexp, $vid_value, $matches);
      $input_terms = array_unique($matches[1]);

      $inserted = array();
      foreach ($input_terms as $input_term) {
        // If a user has escaped a term (to demonstrate that it is a group, or
        // includes a comma or quote character), we remove the escape formatting
        // so to save the term into the database as the user intends.
        $input_term = str_replace('""', '"', preg_replace('/^"(.*)"$/', '\1', $input_term));
        $input_term = trim($input_term);
        if ($input_term == '') {
          continue;
        }

        // Return the term's tid. Note: This assumes that taxonomy_node_save()
        // has been called previously!
        $possibilities = taxonomy_get_term_by_name($input_term);
        $input_term_tid = NULL; // tid match, if any.
        foreach ($possibilities as $possibility) {
          if ($possibility->vid == $vid) {
            // Note: Should break here, but taxonomy_node_save() doesn't. Can't
            // save $input_term_tid in $tids here, since that would append all
            // the possibilities instead of the last one.
            $input_term_tid = $possibility->tid;
          }
        }
        if ($input_term_tid) {
          $tids[] = $input_term_tid;
        }
      }
    }
  }
  
  // Collect the taxonomy terms to save.
  foreach ($terms as $key => $value) {
    if (is_array($value)) {
      // We are looking at an array of tids indexed by vid.
      if (isset($vocabularies[$key])) {
        $tids = array_merge($tids, $value);
      }
    }
    elseif (is_object($value)) {
      // We are looking at a term. Note: Not sure how this can happen, but it
      // has been reported, and taxonomy_node_save() handles this case.
      if (isset($vocabularies[$value->vid])) {
        $tids[] = $value->tid;
      }
    }
    elseif ($value) {
      // We are looking at a tid. Note: Not sure how this can happen, but
      // taxonomy_node_save() handles this case.
      if (isset($vocabularies[$key])) {
        $tids[] = $value;
      }
    }
  }
  if ($tids) {
    _taxonomy_facets_save_term_node($nid, $tids);
  }
}

/**
 * Save the specified terms (and their ancestors) in the
 * taxonomy_facets_term_node table.
 */
function _taxonomy_facets_save_term_node($nid, $tids) {
  foreach ($tids as $tid) {
    $ancestors = taxonomy_get_parents_all($tid);
    foreach ($ancestors as $term) {
      // If term has not been inserted yet, insert it (multiple terms may share
      // common ancestors)
      if (!isset($inserted[$term->tid])) {
        $inserted[$term->tid] = TRUE;
        db_query("INSERT INTO {taxonomy_facets_term_node} (nid, tid) VALUES (%d, %d)", $nid, $term->tid);
      }
    }
  }
}

/**
 * Clear the saved term associations for the specified node.
 */
function _taxonomy_facets_clear_term_node($nid) {
  db_query("DELETE FROM {taxonomy_facets_term_node} WHERE nid = %d", $nid);
}

